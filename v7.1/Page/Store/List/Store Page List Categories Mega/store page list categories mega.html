<!-- begin TWC Store Page List Categories Mega -->

  <!--
  
    begin store page list categories mega
    
    License       : < https://tinyurl.com/s872fb68 >
    
    Version       : 0.5.0
    
    SS Version    : 7.1
    
    Fluid
    Engine
    Compatible    : Not Applicable
    
    Dependencies  : store categories cache < https://tinyurl.com/285tkudd >
    
    Notes         : the code is comprised of a style and script tag. both are
                    needed for the full effect to work
                    
                    in the editor when you change the CATEGORIES TYPE
                    (Sidebar/Top) you will see Squarespace's default style of
                    categories until you save the page. If for some reason the
                    categories don't update after saving the page, refresh the
                    page
    
    Copyright     : 2023-2025 Thomas Creedon
                       
                    Tom's Web Consulting < http://www.tomsWeb.consulting/ >
    
    no user serviceable parts below
    
    -->
    
  <style>
  
    /* begin resets */
    
      .twc-splcm .nested-category-breadcrumb-list-item {
      
        display : unset;
        
        }
        
      .twc-splcm .nested-category-breadcrumb-list-item .nested-category-breadcrumb-link {
      
        margin : unset !important;
        
        }
        
      /* end resets */
      
    /* begin hide */
    
      /* begin category */
      
        /* side */
        
        body:not( .sqs-is-page-editing ) .nested-category-tree-wrapper,
        body:not( .sqs-is-page-editing ) .nested-category-children /* top */
        
        /* end category */
        
      {
      
        display : none;
        
        }
        
      /* end hide */
      
    /* begin overrides */
    
      .twc-splcm {
      
        margin-block-end : unset;
        margin-block-start : unset;
        padding-inline-start : unset;
        
        }
        
      .twc-splcm ul {
      
        padding-inline-start : var( --twc-splcm-spacing-left );
        
        }
        
      /* end overrides */
      
    .product-list {
    
      --twc-product-list-visibility : hidden;
      
      visibility : var( --twc-product-list-visibility );
      
      }
      
    div[ data-category-display-type="sidebar" ] .twc-splcm {
    
      float : left;
      margin-right : 40px;
      max-width : 300px;
      min-width : 220px;
      
      }
      
    div[ data-category-display-type="top" ] .twc-splcm {
    
      border-bottom: 1px solid rgba( 0, 0, 0, 0.2 );
      margin-bottom : 37px;
      padding : 54px 0;
      
      }
      
    div[ data-category-display-type="top" ] .twc-splcm {
    
      display : flex;
      
      }
      
    div[ data-category-display-type="top" ] .twc-splcm {
    
      display : flex;
      
      }
      
    div[ data-header-text-alignment="center" ] .twc-splcm {
    
      justify-content : center;
      
      }
      
    body.sqs-is-page-editing .twc-splcm {
    
      display : none;
      
      }
      
    .twc-splcm ul:not( :has( details ) ) {
    
      padding-inline-start : calc( var( --twc-splcm-spacing-left ) * 1.5 );
      
      }
      
    div[ data-category-display-type="top" ] .twc-splcm ul {
    
      display : flex;
      gap : 0.75em;
      
      }
      
    .twc-splcm .breadcrumb-separator {
    
      display : unset !important;
      margin-left : 0.6em
      
      }
      
    .twc-splcm .nested-category-breadcrumb-link.active {
    
      cursor : default;
      font-weight : 700;
      
      }
      
    div[ data-category-display-type="sidebar" ] .twc-splcm .breadcrumb-separator,
    div[ data-category-display-type="top" ] .twc-splcm .nested-category-breadcrumb-list-item:last-child > .breadcrumb-separator
    
      {
      
        display : none !important;
        
        }
        
    .twc-splcm summary {
    
      display : list-item;
      
      }
      
    .twc-splcm summary::marker {
    
      font-size : larger;
      
      }
      
    </style>
    
  <script>
  
    ( ( ) => {
    
      const
      
        version = '0.5.0',
        
        s = `
        
          Store Page List Categories Mega v${ version }
          
          License < https://tinyurl.com/s872fb68 >
          
          Â© 2023-2025 Thomas Creedon
          
          Tom's Web Consulting < http://www.tomsWeb.consulting >
          
          `
          
          .replace ( /^\s+/gm, '' );
          
      console.log ( s );
      
      // initialize twc module
      
      window.twc = ( ( self ) => self ) ( window.twc || { } );
      
      // initialize twc splcc sub-module
      
      twc.splcc = ( ( self ) => self ) ( twc.splcc || { } );
      
      // initialize twc splcc callbacks sub-module
      
      twc.splcc.callbacks = ( ( self ) => {
      
        const callback = ( categories ) => {
        
          const callback = ( ) => {
            
            const
            
              codeKey = 'twc-splcm',
              
              selectorKey = '.product-list';
              
            // hide show register
            
            {
            
              // initialize twc data sub-module
              
              twc.data = ( ( self ) => self ) ( twc.data || { } );
              
              // initialize twc data hideShow sub-module
              
              twc.data.hideShow =
              
                ( ( self ) => self ) ( twc.data.hideShow || { } );
                
              if ( twc.data.hideShow [ selectorKey ] === undefined )
              
                twc
                
                  .data
                  
                  .hideShow
                  
                  [ selectorKey ]
                  
                  =
                  
                  [ ];
                  
              twc
              
                .data
                
                .hideShow
                
                [ selectorKey ]
                
                .push ( `--${ codeKey }` );
                
              }
              
            {
            
              const
              
                getCategoryUrlSlug = ( ) => {
                
                  const pathname = location
                  
                    .pathname;
                    
                  let slug = pathname
                  
                    .slice (
                    
                      url
                      
                        .length
                        
                        +
                        
                        1
                        
                      );
                      
                  if ( ! slug ) return ''; // bail if no slug
                  
                  slug = pathname
                  
                    .replace ( url, '' );
                    
                  return slug;
                  
                  },
                  
                getParents = ( element, selector ) => {
                
                  const parents = [ ];
                  
                  let current = element
                  
                    .parentElement;
                    
                  while ( current ) {
                  
                    if ( ! selector || current.matches ( selector ) )
                    
                      parents.push ( current );
                      
                    current = current.parentElement;
                    
                    }
                    
                  return parents;
                  
                  },
                  
                options = codeKey
                
                  .split ( '-' )
                  
                  .reduce ( ( obj, key ) => obj?.[ key ], window ),
                  
                traverse = ( categories, ulElement ) => {
                
                  const callback = ( category ) => {
                  
                    const hasChildren = category
                    
                      .children
                      
                      .length;
                    
                    let liElement = document
                    
                      .createElement ( 'template' );
                      
                    liElement.innerHTML = `
                    
                      <li class="children nested-category-breadcrumb-list-item">
                      
                        <a class="nested-category-breadcrumb-link" href="${ category.fullUrl }">
                        
                          ${ category.displayName }
                          
                          </a>
                          
                        <span class="breadcrumb-separator" aria-hidden="true">
                        
                          |
                          
                          </span>
                          
                        </li>
                        
                      `;
                      
                    liElement = liElement
                    
                      .content
                      
                      .firstElementChild;
                      
                    let element;
                    
                    if ( hasChildren ) {
                    
                      element = wrap (
                      
                        liElement
                        
                          .querySelector (
                          
                            '.nested-category-breadcrumb-link'
                            
                            ),
                            
                        `
                        
                          <details open>
                          
                            <summary>
                            
                              </summary>
                              
                              </details>
                              
                          `
                          
                        );
                        
                      if ( ! options.categoriesExpandedOnLoad )
                      
                        element
                        
                          .removeAttribute ( 'open' );
                          
                      } else {
                      
                        liElement
                        
                          .classList
                          
                          .remove ( 'children' );
                          
                        element = liElement;
                        
                        }
                        
                    ulElement
                    
                      .append ( liElement );
                      
                    if ( ! hasChildren ) return; // continue
                    
                    const childrenUlElement = document
                    
                      .createElement ( 'ul' )
                      
                    element.append ( childrenUlElement );
                    
                    traverse ( category.children, childrenUlElement );
                    
                    }
                    
                  categories
                  
                    .forEach ( callback );
                    
                  },
                  
                ulElement = document
                
                  .createElement ( 'ul' ),
                  
                url = Static
                   
                  .SQUARESPACE_CONTEXT
                  
                  .collection
                  
                  .fullUrl,
                  
                windowWidth = document
                
                  .documentElement
                  
                  .clientWidth,
                  
                wrap = ( target, wrapper = '<div>' ) => {
                
                  const
                  
                    callback = ( element ) => {
                    
                      let
                      
                        deepestElement,
                  
                        outerWrapperElement;
                        
                      if ( typeof wrapper === 'string' ) {
                      
                        // parse html string into dom
                        
                        {
                        
                          const element = document
                          
                            .createElement ( 'template' );
                            
                          element.innerHTML = wrapper
                          
                            .trim ( );
                            
                          outerWrapperElement = element
                          
                            .content
                            
                            .firstElementChild;
                            
                          // bail if no outer wrapper element
                          
                          if ( ! outerWrapperElement ) return;
                          
                          }
                          
                        // deepest element
                        
                        {
                        
                          deepestElement = outerWrapperElement;
                          
                          while ( deepestElement.firstElementChild )
                          
                            deepestElement = deepestElement.firstElementChild;
                            
                          }
                          
                        } else if ( wrapper instanceof Element ) {
                        
                          // clone dom element to avoid reuse
                          
                          outerWrapperElement = wrapper
                          
                            .cloneNode ( false );
                            
                          deepestElement = outerWrapperElement;
                          
                          } else {
                          
                            const s = 'Invalid wrapper type: must be HTML '
                            
                              +
                              
                              'string or DOM element';
                              
                            throw new Error ( s );
                            
                            }
                            
                      // insert and wrap
                      
                      {
                      
                        if ( element.parentNode )
                        
                          element
                          
                            .parentNode
                            
                            .insertBefore (
                            
                              outerWrapperElement,
                              
                              element
                              
                              );
                              
                        deepestElement
                        
                          .appendChild ( element );
                          
                        }
                        
                      wrappers
                      
                        .push ( outerWrapperElement );
                        
                      },
                      
                    elements
                    
                      =
                      
                      typeof target === 'string'
                      
                      ?
                      
                      document
                      
                        .querySelectorAll ( target )
                        
                      :
                      
                      target instanceof NodeList
                      
                      ?
                      
                      target
                      
                      :
                      
                      [ target ];
                      
                  let wrappers = [ ];
                    
                  elements.forEach ( callback );
                  
                  wrappers = wrappers
                  
                    .length
                    
                    ===
                    
                    1
                    
                    ?
                    
                    wrappers [ 0 ]
                    
                    :
                    
                    wrappers;
                    
                  return wrappers;
                  
                  },
                  
                categoryUrlSlug = getCategoryUrlSlug ( );
                
              let
              
                element,
                
                selector;
                
              ulElement
              
                .classList
                
                .add ( codeKey );
                
              if ( options.hideIcon )
              
                ulElement
                
                  .setAttribute ( `data-${ codeKey }-hide-icon`, '' );
                  
              traverse ( categories, ulElement );
              
              // set initial active and open
              
              {
              
                selector = `[ href="${ url }${ categoryUrlSlug }" ]`;
                
                element = ulElement
                
                  .querySelector ( selector );
                  
                element
                
                  .classList
                  
                  .add ( 'active' );
                  
                element
                
                  .removeAttribute ( 'href' );
                  
                getParents ( element, 'details' )
                
                  .forEach ( e => e.setAttribute ( 'open', '' ) );
                  
                }
                
              // add categories mega
              
              {
              
                element = document
                
                  .body
                  
                  .querySelector ( '.product-list-container' );
                  
                element
                
                  .parentNode
                  
                  .insertBefore (
                  
                    ulElement,
                    
                    element
                    
                    );
                    
                }
                
              }
              
            // hide show unregister
            
            {
            
              twc
              
                .data
                
                .hideShow
                
                [ selectorKey ]
                
                .pop ( `--${ codeKey }` );
                
              const
              
                l = twc
                
                  .data
                  
                  .hideShow
                  
                  [ selectorKey ]
                  
                  .length,
                  
                productListElement = document
                
                  .querySelector ( '.product-list' );
                  
              if ( ! l )
              
                productListElement
                
                  .style
                  
                  .setProperty ( '--twc-product-list-visibility', 'visible' );
                  
              }
              
            };
            
          document
           
            .addEventListener ( 'DOMContentLoaded', callback );
            
          };
          
        self.push ( callback );
        
        return self;
        
        } ) ( twc.splcc.callbacks || [ ] );
        
      } ) ( );
      
    </script>
    
  <!-- end TWC Store Page List Categories Mega -->
