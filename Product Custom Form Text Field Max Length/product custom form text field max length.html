  <!-- begin TWC Product Custom Form Text Field Max Length -->
  
    <!-- begin TWC Cart Page Observe Changes -->
  
    <script>
    
      ( ( ) => {
      
        /*
        
          cart page observe changes
          
          License         : < https://tinyurl.com/s872fb68 >
          
          Version         : 0.3.0
          
          SS Versions     : 7.1, 7.0
          
          v7.1
          Fluid
          Engine
          Compatible      : Not Applicable
          
          Note            : this code is a base for other effects. on its own it
                            doesn't do anything. this code is not the end all be
                            all of mutation observers. it may not cover your needs
          
          Copyright       : 2022-2026 Thomas Creedon
                            
                            Tom's Web Consulting
                            
                            < http://www.tomsWeb.consulting/ >
          
          no user serviceable parts below
          
          */
          
        const
        
          version = '0.3.0',
          
          s = `Cart Page Observe Changes v${ version }
          
            License < https://tinyurl.com/s872fb68 >
            
            © 2022-2026 Thomas Creedon
            
            Tom's Web Consulting < http://www.tomsWeb.consulting >`
            
            .replace ( /^\s+/gm, '' );
            
        console.log ( s );
        
        const isCartPage =
        
          location.pathname === '/cart';
        
        if ( ! isCartPage ) return; // bail if not cart page
        
        const hasMutationObserver =
        
          ( 'MutationObserver' in window );
          
        // bail if no mutation observer available
        
        if ( ! hasMutationObserver ) return;
        
        const dclCallback = ( ) => {
        
          // globals
          
          {
        
            // initialize twc module
            
            window.twc =
            
              ( ( self ) => self ) ( window.twc || { } );
              
            // initialize twc cpoc sub-module
            
            twc.cpoc =
            
              ( ( self ) => self ) ( twc.cpoc || { } );
            
            // initialize twc cpoc callbacks sub-module
            
            twc.cpoc.callbacks =
            
              ( ( self ) => self )
              
              ( twc.cpoc.callbacks || { } );
              
            // initialize twc cpoc callbacks added sub-module
            
            twc.cpoc.callbacks.added =
            
              ( ( self ) => self )
              
              ( twc.cpoc.callbacks.added || [ ] );
              
            // initialize twc cpoc callbacks removed sub-module
            
            twc.cpoc.callbacks.removed =
            
              ( ( self ) => self )
              
              ( twc.cpoc.callbacks.removed || [ ] );
              
            }
            
          const
          
            codeKey = `twc-cpoc`,
            
            options = codeKey
            
              .split ( '-' )
              
              .reduce ( ( obj, key ) => obj?.[ key ], window ),
              
            hasAddedCallbacks = options
            
              .callbacks
              
              .added
              
              .length,
              
            hasRemovedCallbacks = options
            
              .callbacks
              
              .removed
              
              .length,
              
            hasCallbacks =
            
              hasAddedCallbacks || hadRemovedCallbacks;
              
          if ( ! hasCallbacks ) return; // bail if no callbacks
          
          const
          
            mutationCallback = ( mutation ) => {
            
              mutation
              
                .addedNodes
                
                .forEach ( n => nodeCallback ( n ) );
                
              mutation
              
                .removedNodes
                
                .forEach (
                
                  n => nodeCallback ( n, 'removed' )
                  
                  );
                  
              },
              
            mutationsCallback = ( mutations ) => {
            
              mutations.forEach ( mutationCallback );
              
              },
              
            nodeCallback = ( node, key = 'added' ) => {
            
              options
              
                .callbacks
                
                [ key ]
                
                .forEach (
                
                  c => runCallback ( c, node )
                  
                  );
                  
              },
              
            observer = new MutationObserver (
            
              mutationsCallback
              
              ),
              
            runCallback = ( callback, node ) => {
            
              try {
              
                callback ( node );
                
                } catch ( error ) {
                
                  const s = `${ codeKey } callback error`;
                  
                  console.error ( s, error );
                  
                  }
                  
              };
              
          // start listening for changes in body
          
          observer.observe (
          
            document.getElementById (
            
              'sqs-cart-container'
              
              ),
              
            {
            
              childList : true,
              
              subtree : true
              
              }
              
            );
            
          };
          
        document.addEventListener (
        
          'DOMContentLoaded',
          
          dclCallback
          
          );
          
        } ) ( );
        
      </script>
      
    <!-- end TWC Cart Page Observe Changes -->
  
  <!-- begin TWC Form Inner Wrapper Observe Changes -->
  
    <script>
    
      ( ( ) => {
      
        /*
        
          form inner wrapper observe changes
          
          License         : < https://tinyurl.com/s872fb68 >
          
          Version         : 0.1.1
          
          SS Versions     : 7.1, 7.0
          
          v7.1
          Fluid
          Engine
          Compatible      : Not Applicable
          
          v7.0
          Templates       : Brine ( Aria, Blend, Burke, Cacao, Clay, Fairfield, Feed,
                            Foster, Greenwich, Hatch, Heights, Hunter, Hyde, Impact,
                            Jaunt, Juke, Keene, Kin, Lincoln, Maple, Margot, Marta,
                            Mentor, Mercer, Miller, Mojave, Moksha, Motto, Nueva,
                            Pedro, Pursuit, Rally, Rover, Royce, Sofia, Sonora,
                            Stella, Thorne, Vow, Wav, West )
                            
                            your template is not listed? then it is not currently
                            supported
          
          Dependencies    : modal lightbox observe changes
                            
                            < https://tinyurl.com/877wczvk >
          
          Copyright       : 2026 Thomas Creedon
                            
                            Tom's Web Consulting < http://www.tomsWeb.consulting/ >
          
          no user serviceable parts below
          
          */
          
        const
        
          version = '0.1.1',
          
          s = `Form Inner Wrapper Observe Changes v${ version }
          
            License < https://tinyurl.com/s872fb68 >
            
            © 2026 Thomas Creedon
            
            Tom's Web Consulting < http://www.tomsWeb.consulting >`
            
            .replace ( /^\s+/gm, '' );
            
        console.log ( s );
        
        // initialize twc module
        
        window.twc = ( ( self ) => self ) ( window.twc || { } );
        
        // initialize twc fiwoc sub-module
        
        twc.fiwoc = ( ( self ) => self ) ( twc.fiwoc || { } );
        
        // initialize twc fiwoc callbacks sub-module
        
        twc.fiwoc.callbacks =
        
          ( ( self ) => self ) ( twc.fiwoc.callbacks || [ ] );
          
        // initialize twc mloc sub-module
        
        twc.mloc = ( ( self ) => self ) ( twc.mloc || { } );
        
        // initialize twc mloc callbacks sub-module
        
        twc.mloc.callbacks = ( ( self ) => {
        
          const callback = ( element ) => {
          
            const
            
              codeKey = 'twc-fiwoc',
              
              options = codeKey
              
                .split ( '-' )
                
                .reduce ( ( obj, key ) => obj?.[ key ], window ),
                
              hasCallbacks = options
              
                .callbacks
                
                .length;
                
            if ( ! hasCallbacks ) return; // bail if no callbacks
            
            const
            
              mutationCallback = ( mutation ) => {
              
                mutation
                
                  .addedNodes
                  
                  .forEach ( nodeCallback );
                  
                },
                
              mutationsCallback = ( mutations ) => {
              
                mutations.forEach ( mutationCallback );
                
                },
                
              nodeCallback = ( node ) => {
              
                options
                
                  .callbacks
                  
                  .forEach (
                  
                    c => runCallback ( c, node )
                    
                    );
                    
                },
                
              observer = new MutationObserver (
              
                mutationsCallback
                
                ),
                
              runCallback = ( callback, element ) => {
              
                try {
                
                  callback ( element );
                  
                  } catch ( error ) {
                  
                    const s = `${ codeKey } callback error`;
                    
                    console.error ( s, error );
                    
                    }
                    
                };
                
            element = element
            
              .querySelector ( '.form-inner-wrapper' );
              
            if ( ! element ) return; // bail if no element
            
            // start listening for changes in form inner wrapper
            
            observer.observe (
            
              element,
              
              { childList : true }
              
              );
              
            };
            
          self.push ( callback );
          
          return self;
          
          } ) ( twc.mloc.callbacks || [ ] );
          
        } ) ( );
        
      </script>
      
    <!-- end TWC Form Inner Wrapper Observe Changes -->
  
  <!-- begin TWC Modal Lightbox Observe Changes -->
  
    <script>
    
      ( ( ) => {
      
        /*
        
          modal lightbox observe changes
          
          License         : < https://tinyurl.com/s872fb68 >
          
          Version         : 0.2.0
          
          SS Versions     : 7.1, 7.0
          
          v7.1
          Fluid
          Engine
          Compatible      : Not Applicable
          
          Note            : this code is a base for other effects. on its own it
                            doesn't do anything. this code is not the end all be
                            all of mutation observers. it may not cover your needs
          
          Copyright       : 2024-2026 Thomas Creedon
                            
                            Tom's Web Consulting
                            
                            < http://www.tomsWeb.consulting/ >
          
          no user serviceable parts below
          
          */
          
        const
        
          version = '0.2.0',
          
          s = `Modal Lightbox Observe Changes v${ version }
          
            License < https://tinyurl.com/s872fb68 >
            
            © 2024-2026 Thomas Creedon
            
            Tom's Web Consulting < http://www.tomsWeb.consulting >`
            
            .replace ( /^\s+/gm, '' );
            
        console.log ( s );
        
        const callback = ( ) => {
        
          // globals
          
          {
        
            // initialize twc module
            
            window.twc = ( ( self ) => self ) ( window.twc || { } );
            
            // initialize twc mloc sub-module
            
            twc.mloc = ( ( self ) => self ) ( twc.mloc || { } );
            
            // initialize twc mloc callbacks sub-module
            
            twc.mloc.callbacks =
            
              ( ( self ) => self ) ( twc.mloc.callbacks || [ ] );
              
            }
            
          const
          
            codeKey = `twc-mloc`,
            
            options = codeKey
            
              .split ( '-' )
              
              .reduce ( ( obj, key ) => obj?.[ key ], window ),
              
            hasCallbacks = options
            
              .callbacks
              
              .length;
              
          if ( ! hasCallbacks ) return; // bail if no callbacks
          
          const
          
            mutationCallback = ( mutation ) => {
            
              mutation
              
                .addedNodes
                
                .forEach ( nodeCallback );
                
              },
              
            mutationsCallback = ( mutations ) => {
            
              mutations.forEach ( mutationCallback );
              
              },
              
            nodeCallback = ( node ) => {
            
              const isElement = node
              
                .nodeType
                
                ===
                
                1;
                
              if ( ! isElement ) return; // bail if not element
              
              const isModalLightbox = node
              
                .classList
                
                .contains ( 'sqs-modal-lightbox' );
                
              // bail if not element of interest
              
              if ( ! isModalLightbox ) return;
              
              options
              
                .callbacks
                
                .forEach (
                
                  c => runCallback ( c, node )
                  
                  );
                  
              },
              
            observer = new MutationObserver (
            
              mutationsCallback
              
              ),
              
            runCallback = ( callback, node ) => {
            
              try {
              
                callback ( node );
                
                } catch ( error ) {
                
                  const s = `${ codeKey } callback error`;
                  
                  console.error ( s, error );
                  
                  }
                  
              };
              
          // start listening for changes in body
          
          observer.observe (
          
            document.body,
            
            { childList : true }
            
            );
            
          };
          
        document.addEventListener (
        
          'DOMContentLoaded',
          
          callback
          
          );
          
        } ) ( );
        
      </script>
      
    <!-- end TWC Modal Lightbox Observe Changes -->
  
  <!-- begin TWC Form Text Field Max Length Data -->
  
    <script>
    
      ( ( ) => {
      
        /*
        
          form text field max length data
          
          License         : < https://tinyurl.com/s872fb68 >
          
          Version         : 0.1.0
          
          SS Versions     : 7.1, 7.0
          
          v7.1
          Products V2
          Compatible      : Yes
          
          v7.1
          Fluid
          Engine
          Compatible      : Yes
          
          Dependencies    : cart page observe changes
                            
                            < https://tinyurl.com/2tbppm2v >
          
          Notes           : this code is a base for other effects
                          
                            this code makes calls to the json version of products
                            for information that is not normally available
          
                            this code does not work on the checkout page. it is a
                            Squarespace security feature that no code can alter
                            the checkout page
          
          Copyright       : 2026 Thomas Creedon
                            
                            Tom's Web Consulting < http://www.tomsWeb.consulting/ >
          
          no user serviceable parts below
          
          */
          
        const
        
          version = '0.1.0',
          
          s = `
          
            Form Text Field Max Length Data v${ version }
            
            License < https://tinyurl.com/s872fb68 >
            
            © 2026 Thomas Creedon
            
            Tom's Web Consulting < http://www.tomsWeb.consulting >
            
            `
            
            .replace ( /^\s+/gm, '' );
            
        console.log ( s );
        
        // initialize twc module
        
        window.twc = ( ( self ) => self ) ( window.twc || { } );
        
        // initialize twc ftfmld sub-module
        
        twc.ftfmld = ( ( self ) => {
        
          const options = {
          
            ids : [ ]
            
            };
            
          Object
          
            .assign (
            
              self,
              
              options
              
              );
              
          return self;
          
          } ) ( twc.ftfmld || { } );
          
        // initialize twc cpoc sub-module
        
        twc.cpoc =
        
          ( ( self ) => self ) ( twc.cpoc || { } );
          
        // initialize twc cpoc callbacks sub-module
        
        twc.cpoc.callbacks =
        
          ( ( self ) => self )
          
          ( twc.cpoc.callbacks || { } );
          
        // initialize twc cpoc callbacks added sub-module
        
        twc.cpoc.callbacks.added =
        
          ( ( self ) => {
          
            const callback = async ( node ) => {
            
              const isElement = node
              
                .nodeType
                
                ===
                
                1;
                
              if ( ! isElement ) return; // bail if not element
              
              const isCartContainer = node
              
                .getAttribute ( 'data-test' )
                
                ===
                
                "cart-container";
                
              // bail if not element of interest
              
              if ( ! isCartContainer ) return;
              
              const
              
                fetchJsonBatch = async ( urls ) => {
                
                  try {
                  
                    const responses = await Promise.all (
                    
                      urls.map ( async ( url ) => {
                      
                        const response = await fetch ( url );
                        
                        if ( ! response.ok ) {
                        
                          const s = `
                          
                            ${ codeKey } network response was not ok ${ response.statusText }
                            
                            `
                            
                            .trim ( )
                            
                            .replace ( /\s+/gm, ' ' );
                            
                          throw new Error ( s );
                          
                          }
                          
                        return response.json ( );
                        
                      } )
                      
                    );
                    
                    return responses; // array of JSON objects
                    
                  } catch ( error ) {
                  
                    const s = `
                    
                      ${ codeKey } there has been a problem with your fetch batch operation,
                      
                      ${ error }.
                      
                      `
                      
                      .trim ( )
                      
                      .replace ( /\s+/gm, ' ' );
                      
                    console.error ( s );
                    
                    return null;
                    
                    }
                    
                  },
                  
                urls = [
                
                  ...
                  
                  node
                  
                    .querySelectorAll ( '.cart-row-title' )
                    
                  ]
                  
                  .map (
                  
                    e => `${ e.getAttribute ( 'href' ) }?format=json`
                    
                    ),
                    
                results = await fetchJsonBatch ( urls );
                
              if ( ! results ) return; // bail if no results
              
              results.forEach ( o => {
              
                const item = o.item;
                
                options.ids.push ( item.id );
                
                item
                
                  .variants
                  
                  .forEach (
                  
                    v => options.ids.push ( v.sku )
                    
                    );
                    
                } );
                
              };
              
            self.push ( callback );
            
            return self;
            
            } ) ( twc.cpoc.callbacks.added || [ ] );
            
        const
        
          codeKey = 'twc-ftfmld',
          
          collectClassNames = ( obj, a = [ ] ) => {
          
            for ( const key in obj ) {
            
              const
              
                value = obj [ key ],
                
                isOject =
                
                  value && typeof value === 'object',
                  
                isString = typeof value === 'string';
                
              if ( isString )
              
                a.push ( value );
                
                else if ( isOject )
                
                  collectClassNames ( value, a );
                  
              }
              
            return a;
            
            },
            
          dclCallback = async ( ) => {
          
            const
            
              isList
              
                =
                
                !
                
                Static
                
                  .SQUARESPACE_CONTEXT
                  
                  .item
                  
                  ?.id,
                  
              isStorePage = Static
              
                .SQUARESPACE_CONTEXT
                
                .collection
                
                ?.type
                
                ===
                
                13,
                
              isStorePageList =
              
                isStorePage && isList;
                
            if ( isStorePageList ) {
            
              try {
              
                const url = Static
                
                  .SQUARESPACE_CONTEXT
                  
                  .collection
                  
                  .fullUrl
                  
                  +
                  
                  '?format=json';
                  
                const response = await fetch ( url );
                
                if ( ! response.ok ) {
                
                  const s = `
                  
                    ${ codeKey } network response was not ok ${
                    
                      response
                      
                        .statusText
                        
                        }
                        
                    `
                    
                    .trim ( )
                    
                    .replace ( /\s+/gm, ' ' );
                    
                  throw new Error ( s );
                  
                  }
                  
                const
                
                  itemCallback = ( item ) => {
                  
                    options.ids.push ( item.id );
                    
                    item.variants.forEach (
                    
                      v => options.ids.push ( v.sku )
                      
                      );
                      
                    },
                    
                  obj = await response.json ( );
                  
                obj
                
                  .items
                  
                  .forEach ( itemCallback );
                
                return;
                  
                } catch ( error ) {
                
                  const s = `
                  
                    ${ codeKey } there has been a problem with your fetch get operation,
                    
                    ${ error }.
                    
                    `
                    
                    .trim ( )
                    
                    .replace ( /\s+/gm, ' ' );
                    
                  console.error ( s );
                  
                  }
                  
              }
              
            const
            
              selector = '.sqs-add-to-cart-button-wrapper';
              
            document
            
              .body
              
              .querySelectorAll ( selector )
              
              .forEach ( elementCallback );
              
            },
              
          elementCallback = async ( element ) => {
          
            const
            
              classNames = {
              
                // 7.1, 7.0; product block
                
                productBlock : 'product-block',
                
                '7.1' : {
                
                  // plp : 'product-list-item',
                  
                  pdp : 'product-detail',
                  
                  pdpAddOn : 'product-add-ons'
                  
                  },
                  
                7 : {
                
                  pdp : 'ProductItem-details'
                  
                  }
                  
                },
                
              selector = collectClassNames ( classNames )
              
                .map ( c => `.${ c }` )
                
                .join( ', ' );
                
            element = element.closest ( selector );
            
            const
            
              classList = element.classList,
              
              isPdp
              
                =
                
                classList.contains (
                
                  classNames
                  
                    [ '7.1' ]
                    
                    .pdp
                    
                  )
                  
                ||
                
                classList.contains (
                
                  classNames
                  
                    [ '7' ]
                    
                    .pdp
                    
                  ),
                  
              isPdpAddOn = classList.contains (
              
                classNames
                
                  [ '7.1' ]
                  
                  .pdpAddOn
                  
                ),
                
              isProductBlock = classList
              
                .contains (
                
                  classNames
                  
                    .productBlock
                    
                  );
                  
            switch ( true ) {
            
              case isPdp :
              
                options.ids.push (
                
                  Static.SQUARESPACE_CONTEXT.itemId
                  
                  );
                  
                Static
                
                  .SQUARESPACE_CONTEXT
                  
                  .product
                  
                  .variants
                  
                  .forEach (
                  
                    v => options.ids.push ( v.sku )
                    
                    );
                    
                break;
                
              case isPdpAddOn : {
              
                try {
                
                  const url = element
                  
                    .querySelector ( '.add-on-thumbnail-link' )
                    
                    .getAttribute ( 'href' )
                    
                    +
                    
                    '?format=json';
                    
                  const response = await fetch ( url );
                  
                  if ( ! response.ok ) {
                  
                    const s = `
                    
                      ${ codeKey } network response was not ok ${
                      
                        response
                        
                          .statusText
                          
                          }
                          
                      `
                      
                      .trim ( )
                      
                      .replace ( /\s+/gm, ' ' );
                      
                    throw new Error ( s );
                    
                    }
                    
                  const
                  
                    obj = await response.json ( ),
                    
                    item = obj.item;
                    
                  options.ids.push ( item.id );
                  
                  item
                  
                    .variants
                    
                    .forEach (
                    
                      v => options.ids.push ( v.sku )
                      
                      );
                      
                  } catch ( error ) {
                  
                    const s = `
                    
                      ${ codeKey } there has been a problem with your fetch get operation,
                      
                      ${ error }.
                      
                      `
                      
                      .trim ( )
                      
                      .replace ( /\s+/gm, ' ' );
                      
                    console.error ( s );
                    
                    }
                    
                break;
                
                }
                
              case isProductBlock : {
              
                const obj = JSON.parse (
                
                  element
                  
                    .getAttribute ( 'data-product' )
                    
                  );
                  
                options.ids.push ( obj.id );
                
                obj?.variants.forEach (
                
                  v => options.ids.push ( v.sku )
                  
                  );
                  
                break;
                
                }
                
              }
              
            },
            
          options = codeKey
          
            .split ( '-' )
            
            .reduce ( ( obj, key ) => obj?.[ key ], window );
            
        document
        
          .addEventListener ( 'DOMContentLoaded', dclCallback );
          
        } ) ( );
        
      </script>
      
    <!-- end TWC Form Text Field Max Length Data -->
  
  <!-- begin TWC Product Custom Form Text Field Max Length -->
  
    <!--
    
      product custom form text field max length
      
      License           : < https://tinyurl.com/s872fb68 >
      
      Version           : 0.3.1
      
      SS Versions       : 7.1, 7.0
      
      v7.1
      Fluid
      Engine
      Compatible        : Not Applicable
      
      v7.0 
      Templates         : Brine ( Aria, Blend, Burke, Cacao, Clay, Fairfield,
                          Feed, Foster, Greenwich, Hatch, Heights, Hunter, Hyde,
                          Impact, Jaunt, Juke, Keene, Kin, Lincoln, Maple, Margot,
                          Marta, Mentor, Mercer, Miller, Mojave, Moksha, Motto,
                          Nueva, Pedro, Pursuit, Rally, Rover, Royce, Sofia,
                          Sonora, Stella, Thorne, Vow, Wav, West )
                          
                          your template is not listed? then it is not currently
                          supported
      
      Dependencies      : form inner wrapper observe changes
                          
                          < https://tinyurl.com/yjbszby7 >
      
                        : modal lightbox observe changes
                          
                          < https://tinyurl.com/877wczvk >
      
      Notes             : this code does not work on the checkout page. it is a
                          Squarespace security feature that no code can alter the
                          checkout page
                          
                          this code is client side and making use of an HTML form
                          feature. Since this code is client side it is possible
                          to bypass the max length limit this code is setting. in
                          other words you still need to be checking manually when
                          forms or orders come in to make sure your limits are not
                          being exceeded. consider this code more of an aid to
                          help users not exceed your field max length limits
      
      Copyright         : 2024-2026 Thomas Creedon
                          
                          Tom's Web Consulting < http://www.tomsWeb.consulting/ >
      
      no user serviceable parts below
      
      -->
      
    <style>
    
      input[ placeholder*="ftfml" ] {
      
        visibility : hidden;
        
        }
        
      </style>
      
    <script>
    
      ( ( ) => {
      
        const
        
          version = '0.3.1',
          
          s = `Product Custom Form Text Field Max Length v${ version }
          
            License < https://tinyurl.com/s872fb68 >
            
            © 2024-2026 Thomas Creedon
            
            Tom's Web Consulting < http://www.tomsWeb.consulting >`
            
            .replace ( /^\s+/gm, '' );
            
        console.log ( s );
        
        const elementCallback = ( element ) => {
        
          debugger;
          
          const
          
            codeKey = `twc-pcftfml`,
            
            selector = 'input[ placeholder*="ftfml" ]',
            
            elements = element
            
              .querySelectorAll ( selector );
              
          if ( ! elements.length ) return; // bail if no elements
          
          // const callback = ( ) => {
          
            const callback = ( element ) => {
            
              const
              
                attribute = 'placeholder',
                
                re = /^ftfml\s*:\s*{([^}]+)}\s*/;
              
              let
              
                text = element
                
                  .getAttribute ( attribute ),
                  
                m = text.match ( re );
                
              // clean up placeholder attribute value
              
              {
              
                text = text
                
                  .replace ( m [ 0 ], '' )
                  
                  .trim ( );
                  
                if ( text ) // set/show placeholder or remove
                
                  element
                  
                    .setAttribute ( attribute, text );
                    
                  else
                  
                    element.removeAttribute ( attribute );
                    
                }
                
              let maxLength = m [ 1 ].trim ( );
              
              if ( isNaN ( maxLength ) ) {
              
                const callback = ( key ) => {
                
                  const b = ! twc
                  
                    .ftfmld
                    
                    .ids
                    
                    .includes ( key );
                    
                  if ( b ) return; // bail if no key
                  
                  maxLength = idMaxlengthMap [ key ];
                  
                  };
                  
                const
                
                  json = '{' +
                  
                    maxLength
                    
                      .replace ( /[\s]/g, '' )
                      
                      .split ( ',' )
                      
                      .map ( s => s.replace ( /([^:]+)/, '"$1"' ) )
                      
                      .join ( ',' ) +
                      
                    '}',
                    
                  key = 'default',
                  
                  idMaxlengthMap = JSON.parse ( json );
                  
                maxLength = '';
                
                if ( key in idMaxlengthMap )
                
                  maxLength = idMaxlengthMap [ key ];
                  
                Object
                
                  .keys ( idMaxlengthMap )
                  
                  .forEach ( callback );
                  
                }
                
              if ( maxLength )
              
                element
                
                  .setAttribute ( 'maxlength', maxLength );
                  
              };
              
            elements.forEach ( callback );
            
          };
          
        // initialize twc module
        
        window.twc = ( ( self ) => self ) ( window.twc || { } );
        
        twc.ftfmld = ( ( self ) => {
        
          const options = {
          
            ids : [ ]
            
            };
            
          Object
          
            .assign (
            
              self,
              
              options
              
              );
              
          return self;
          
          } ) ( twc.ftfmld || { } );
          
        // initialize twc fiwoc sub-module
        
        twc.fiwoc = ( ( self ) => self ) ( twc.fiwoc || { } );
        
        // initialize twc fiwoc callbacks sub-module
        
        twc.fiwoc.callbacks = ( ( self ) => {
        
          self.push ( elementCallback );
          
          return self;
          
          } ) ( twc.fiwoc.callbacks || [ ] );
          
        // initialize twc mloc sub-module
        
        twc.mloc = ( ( self ) => self ) ( twc.mloc || { } );
        
        // initialize twc mloc callbacks sub-module
        
        twc.mloc.callbacks = ( ( self ) => {
        
          self.push ( elementCallback );
          
          return self;
          
          } ) ( twc.mloc.callbacks || [ ] );
          
        } ) ( );
        
      </script>
      
    <!-- end TWC Product Custom Form Text Field Max Length -->
  
  <!-- begin TWC Cart Page Form Text Field Max Length -->
  
    <!--
    
      cart page form text field max length
      
      License       : < https://tinyurl.com/s872fb68 >
      
      Version       : 0.1.2
      
      SS Versions   : 7.1, 7.0
      
      v7.1
      Fluid
      Engine
      Compatible    : Not Applicable
      
      Dependencies  : cart page observe changes
      
      Notes         : this code does not work on the checkout page. it is a
                      Squarespace security feature that no code can alter the
                      checkout page
  
                      this code is client side and making use of an HTML form
                      feature. Since this code is client side it is possible to
                      bypass the max length limit this code is setting. in other
                      words you still need to be checking manually when forms or
                      orders come in to make sure your limits are not being
                      exceeded. consider this code more of an aid to help users
                      not exceed your field max length limits
      
      Copyright     : 2024-2025 Thomas Creedon
                      
                      Tom's Web Consulting < http://www.tomsWeb.consulting/ >
      
      no user serviceable parts below
      
      -->
      
    <style>
    
      html:not( .squarespace-damask ) #sqs-cart-container .cart-product-form-wrapper input[ placeholder*="ftfml" ] {
      
        visibility : hidden;
        
        }
        
      </style>
      
    <script>
    
      ( ( ) => {
      
        const
        
          version = '0.1.2',
          
          s = `Cart Page Form Text Field Max Length v${ version }
          
            License < https://tinyurl.com/s872fb68 >
            
            © 2024-2025 Thomas Creedon
            
            Tom's Web Consulting < http://www.tomsWeb.consulting >`
            
            .replace ( /^\s+/gm, '' );
            
        console.log ( s );
        
        // globals
        
        {
        
          // initialize twc module
          
          window.twc = ( ( self ) => self ) ( window.twc || { } );
          
          // initialize twc cpftfml sub-module
          
          twc.cpftfml = ( ( self ) => {
          
            const options = {
            
              ids : undefined
              
              };
              
            Object
            
              .assign (
              
                self,
                
                options
                
                );
                
            return self;
            
            } ) ( twc.cpftfml || { } );
            
          }
          
        } ) ( );
        
      var twcCpftfml = ( node ) => {
      
        const hasQuerySelector
        
          =
          
          node
          
            .querySelector;
            
        if ( ! hasQuerySelector ) return; // bail if no querySelector
        
        let selector;
        
        // cart container
        
        ( ( ) => {
        
          const isCartContainerElement
          
            =
            
            node
            
              .classList
              
              .contains ( 'cart-container' );
              
          // bail if not cart container element
          
          if ( ! isCartContainerElement ) return;
          
          selector = '.cart-row';
          
          const
          
            callback = ( element ) => {
            
              const callback = ( event ) => {
              
                console.log ( event );
                
                const
                
                  callback = ( item ) => {
                  
                    console.log ( item );
                    
                    const b = ! ( 'productForm' in item );
                    
                    if ( b ) return [ ]; // bail if no product form
                    
                    const ids = [ item.productId ];
                    
                    if ( item.sku !== undefined )
                    
                      ids.push ( item.sku );
                      
                    return ids;
                    
                    },
                    
                  i = [
                  
                    ...
                    
                    cartRowElements
                    
                    ]
                    
                    .indexOf (
                    
                      element
                      
                        .closest ( '.cart-row' )
                        
                      ),
                      
                  selector =
                  
                    '#sqs-cart-root script[ type="application/json" ]';
                    
                twc.cpftfml.ids = JSON
                
                  .parse (
                  
                    document
                    
                      .body
                      
                      .querySelector ( selector )
                      
                      .textContent
                      
                    )
                    
                  .cart
                  
                  .items
                  
                  .map ( callback )
                  
                  [ i ];
                  
                };
                
              element.addEventListener ( 'click', callback );
              
              },
              
            cartRowElements = node
            
              .querySelectorAll ( selector );
              
          selector = '.cart-row-edit';
          
          node
          
            .querySelectorAll ( selector )
            
            .forEach ( callback );
            
          } ) ( );
          
        // cart product form container
        
        ( ( ) => {
        
          selector = '.cart-product-form-container';
          
          let elements = node
          
            .querySelector ( selector );
            
          if ( ! elements ) return; // bail if no element
          
          const callback = ( element ) => {
          
            const
            
              attribute = 'placeholder',
              
              re = /^ftfml\s*:\s*{([^}]+)}\s*/;
              
            let
            
              text = element
              
                .getAttribute ( attribute ),
                
              m = text.match ( re );
              
            // clean up placeholder attribute value
            
            {
            
              text = text
              
                .replace ( m [ 0 ], '' )
                
                .trim ( );
                
              if ( text ) // set/show placeholder or remove
              
                element
                
                  .setAttribute ( attribute, text );
                  
                else
                
                  element.removeAttribute ( attribute );
                  
              }
              
            let maxLength = m [ 1 ]
            
              .trim ( );
              
            if ( isNaN ( maxLength ) ) {
            
              const callback = ( key ) => {
              
                const b = ! twc
                
                  .cpftfml
                  
                  .ids
                  
                  .includes ( key );
                  
                if ( b ) return; // bail if no key
                
                maxLength = idMaxlengthMap [ key ];
                
                };
                
              const
              
                json = '{' +
                
                  maxLength
                  
                    .replace ( /[\s]/g, '' )
                    
                    .split ( ',' )
                    
                    .map ( s => s.replace ( /([^:]+)/, '"$1"' ) )
                    
                    .join ( ',' ) +
                    
                  '}',
                  
                key = 'default',
                
                idMaxlengthMap = JSON.parse ( json );
                
              maxLength = '';
              
              if ( key in idMaxlengthMap )
              
                maxLength = idMaxlengthMap [ key ];
                
              Object
              
                .keys ( idMaxlengthMap )
                
                .forEach ( callback );
                
              }
              
            if ( maxLength )
            
              element
              
                .setAttribute ( 'maxlength', maxLength );
                
            };
            
          selector = '.cart-product-form-field-label ' +
          
            'input[ placeholder*="ftfml" ]';
            
          elements = elements
          
            .querySelectorAll ( selector )
            
            .forEach ( callback );
            
          } ) ( );
          
        };
        
      </script>
      
    <!-- end TWC Cart Page Form Text Field Max Length -->
  
      
    <!-- end TWC Product Custom Form Text Field Max Length -->
